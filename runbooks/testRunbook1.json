{
    "exampleName": "harvestRunbooks",
    "name": "Example: Convert existing operational procedures into runbooks",
    "description": "This runbook explains how to convert your existing operational procedures into runbooks. It covers file based procedures and web/wiki based procedures.",
    "steps": [
        {
            "title": "Before you start",
            "description": "<p>This runbook provides a conversion tool and related instructions that assist you in getting started with migrating your current set of operational procedures (file based or web/wiki based) to runbooks.</p><p>The steps in this runbook cover the following activities:</p><ol><li>Install the tool</li><li>Run the tool to convert some troubleshooting pages from the Red Hat OpenShift Container Platform documentation into runbooks</li><li>Import the runbooks to your runbook deployment</li><li>Adjust the tool to convert and import your own runbooks</li></ol><p>The conversion tool is a Node.js based standalone application that is contained within this runbook. Open a command shell to install and work with the tool:</p><ul><li>The command shell does not need to be running within the target deployment.</li><li>You need to have internet access to run the tool with the default configuration.</li><li>You need to have network access to the Runbook Automation API and an API key to authenticate your requests. You will be instructed how to create the API key, and also to delete or recreate the API key in the last step of this runbook, as the&nbsp;API&nbsp;key&nbsp;password&nbsp;will&nbsp;be&nbsp;visible&nbsp;in&nbsp;the&nbsp;execution&nbsp;record&nbsp;of&nbsp;this&nbsp;runbook.</li><li>You need to have the curl command available to import the runbooks to your target deployment.</li><li>You need to have at least version 14.15.4 of the Node.js runtime installed to run the tool.</li><li>There are a few dependencies that you will install as you execute this runbook step by step.</li></ul><p>&nbsp;</p>",
            "number": 1,
            "type": "manual"
        },
        {
            "title": "Install the tool: Prepare to copy each of the code blocks from the subsequent steps into their own files",
            "description": "<p>Create a directory</p><section class=\"rba-command\"><span class=\"rba-command-text\">mkdir conversionTool</span></section><p>and change into that directory:</p><section class=\"rba-command\"><span class=\"rba-command-text\">cd conversionTool</span></section><p>Create the files:</p><section class=\"rba-command\"><span class=\"rba-command-text\">touch config.js crawler.js index.js Link.js package.json parser.js Runbook.js utils.js</span></section><p>The subsequent steps provide the content for these files. Copy-paste the file content into each of those files.</p>",
            "number": 2,
            "type": "manual"
        },
        {
            "title": "File: config.js",
            "description": "<p>This code block contains a list of bullet icon characters. As you copy-paste the code from this and the other code blocks into your own files, make sure that special characters are preserved.</p><pre><code class=\"language-plaintext\">/*\n * config.js\n * Data conversion tool for runbooks (RBA).\n * This tool converts HTML sources (website or local files)\n * into runbooks in the RBA import format.\n * Requires: node (node.js runtime)\n * Version: 1\n * Date: 2022-03-01\n * Author: IBM\n * © Copyright IBM Corp. 2021, 2022  All Rights Reserved.\n * Use as is - no support\n */\n\n/* eslint-disable max-len */\n\n// General instructions:\n// - Review all converted and imported runbooks (both for relevance and for completeness) before publishing them\n//   and making them available for production.\n// - If the converted runbooks do not match your expectations, check if you can achieve better results by tuning\n//   the parameters in this configuration file.\n// - If you are still not satisfied with the results, feel free to modify this sample code and adjust it to your\n//   specific requirements.\n\n// Each of the following patterns describes a combination of expected source document elements that appear in a\n// sequence and that together are to be interpreted as one runbook.\n// The runbook patterns are evaluated in order: As soon as there is a match to the pattern (i.e., a runbook with\n// one or multiple steps has been derived from the document), the remaining patterns are not evaluated.\n// If searching for a runbook title (by titleElementCSS) returns a title, AND if the corresponding search for\n// step titles (by stepTitleElementCSS) returns at least one step, then this pattern is used for the document.\n// You can add or remove patterns as needed, and you can modify patterns to suit you particular needs.\n// Additional hints for some of the pattern properties:\n// - titleElementCSS: Typical candidates are `h1`, `h1.title`, `title`, `h1.topictitle1`\n// - titleIgnoreSubstrings: Drop all potential runbooks if one of those substrings exists within their title.\n//              The actual values in this example are all derived from the Wikipedia-based example below, in\n//              order to suppress creation of some runbooks that seem to be meaningless.\n// - stepTitleInSeparateContainer: If \"false\", then the direct siblings of the step title element are considered\n//              as step content. If \"true\", then the step title is expected to be the child of a parent container\n//              (\"div\"), and the siblings of that parent container are considered as step content.\n//              This property is typically \"false\". It needs to be \"true\" for the IBM Documentation.\n// - stepDefaultListType: Specifies the list type to be used if the list type cannot be detected from the source\n//              document. Valid values are either `ol` (ordered lists) or `ul` (unordered lists).\n// - tagMetaAttributeNames: Interpret the content of all \"meta\" elements with\n//              an attribute name in this list as valid tags for the runbook\n\n// --- Pattern for:\n//     - Plain HTML pages/files\n//     - GitHub pages\n//     - MediaWiki pages\n//     - Some HTML pages/files as exported from MS Word (with particular title and step title convention)\n// eslint-disable-next-line no-unused-vars\nconst PATTERN_STANDARD = {\n    titleElementCSS: `body h1`,\n    titleIgnoreSubstrings: [\n        `File:`, `Help:`, `Portal:`,\n        `Recent changes`, `Related changes`,\n        `Talk:`, `Template:`, `Template talk:`,\n        `User talk:`, `User contributions`\n    ],\n    descriptionElementNames: [`p`, `shortdesc`],\n    descriptionElementClasses: [`MsoNormal`],\n    stepTitleElementCSS: `body h2`,\n    stepTitleInSeparateContainer: false,\n    stepContainerElementNames:  [`div`],\n    stepTextElementNames: [`p`, `h3`, `h4`, `blockquote`],\n    stepTextElementClasses: [`MsoNormal`],\n    stepListElementNames: [`ol`, `ul`],\n    stepListItemElementClasses: [\n        `bx--list__item`,\n        `Markdown-module--list-item--32ShB`,\n        `MsoListParagraph`,\n        `MsoListParagraphCxSpFirst`,\n        `MsoListParagraphCxSpMiddle`,\n        `MsoListParagraphCxSpLast`\n    ],\n    stepDefaultListType: `ol`,\n    stepIgnoreElementNames: [`img`],\n    tagMetaAttributeNames: [`keywords`, `dc.subject`]\n};\n\n// --- Pattern for:\n//     - IBM Documentation pages\n// eslint-disable-next-line no-unused-vars\nconst PATTERN_IBM_DOCUMENTATION = {\n    titleElementCSS: `body h1`,\n    titleIgnoreSubstrings: [`We’re sorry!`, `Continue exploring`],\n    descriptionElementNames: [`p`],\n    descriptionElementClasses: [`section prereq`, `shortdesc`],\n    stepTitleElementCSS: `body h1`,\n    stepTitleInSeparateContainer: false,\n    stepContainerElementNames:  [`div`],\n    stepTextElementNames: [`p`, `h2`, `h3`, `h4`],\n    stepTextElementClasses: [],\n    stepListElementNames: [`ol`, `ul`, `dl`],\n    stepListItemElementClasses: [`dlterm`, `dlentry`],\n    stepDefaultListType: `ol`,\n    stepIgnoreElementNames: [`img`],\n    tagMetaAttributeNames: [`keywords`, `dc.subject`]\n};\n\n// --- Pattern for:\n//     - Some HTML pages/files as exported from MS Word (with particular title and step title convention)\n// eslint-disable-next-line no-unused-vars\nconst PATTERN_MSO = {\n    titleElementCSS: `body p.MsoTitle`,\n    titleIgnoreSubstrings: [],\n    descriptionElementNames: [],\n    descriptionElementClasses: [`MsoNormal`],\n    stepTitleElementCSS: `body h1`,\n    stepTitleInSeparateContainer: false,\n    stepContainerElementNames:  [`div`],\n    stepTextElementNames: [],\n    stepTextElementClasses: [`MsoNormal`],\n    stepListElementNames: [],\n    stepListItemElementClasses: [\n        `MsoListParagraph`,\n        `MsoListParagraphCxSpFirst`,\n        `MsoListParagraphCxSpMiddle`,\n        `MsoListParagraphCxSpLast`\n    ],\n    stepDefaultListType: `ol`,\n    stepIgnoreElementNames: [`img`],\n    tagMetaAttributeNames: [`keywords`, `dc.subject`]\n};\n\n// --- Pattern for:\n//     - Documents that have their title defined as a \"title\" element outside of the\n//       document body\n//     - Therefore, the paragraphs next to the title are not suitable to be interpreted\n//       as the document description (as indicated by `ignore-non-body-description`; you\n//       could also just leave these properties empty)\n// eslint-disable-next-line no-unused-vars\nconst PATTERN_TITLE_H1 = {\n    titleElementCSS: `title`,\n    titleIgnoreSubstrings: [],\n    descriptionElementNames: [`ignore-non-body-description`],\n    descriptionElementClasses: [`ignore-non-body-description`],\n    stepTitleElementCSS: `main h1`,\n    stepTitleInSeparateContainer: false,\n    stepContainerElementNames:  [`div`],\n    stepTextElementNames: [`p`],\n    stepTextElementClasses: [],\n    stepListElementNames: [`ol`, `ul`],\n    stepListItemElementClasses: [],\n    stepDefaultListType: `ol`,\n    stepIgnoreElementNames: [`img`],\n    tagMetaAttributeNames: [`keywords`, `dc.subject`]\n};\n\n// --- Pattern for:\n//     - Pages that do not use various levels of headings to distinguish between the\n//       title and the steps, but just contain a title and then various paragraphs\n//     - To distinguish the \"higher level paragraphs\" that should end up as step titles\n//       from \"paragraphs with plain content\" in our test file (as derived from a document\n//       that was originally created using LibreOffice, and then exported to HTML), we\n//       use the paragraph-level class \"p.Text_20_body\" to find the step titles.\n//     - The beginning of that step-level information is also repeated in the runbook\n//       description (as configured in descriptionElementNames/descriptionElementClasses).\n//     - For our test files, this pattern is the \"last resort\" if no other pattern matches.\n//     - Obviously, this pattern may or may not match for your files, but it shows another\n//       way how to use the stepTitleElementCSS for structuring the input data.\n// eslint-disable-next-line no-unused-vars\nconst PATTERN_H1_PARAGRAPH = {\n    titleElementCSS: `body h1`,\n    titleIgnoreSubstrings: [],\n    descriptionElementNames: [`p`],\n    descriptionElementClasses: [`Text_20_body`],\n    stepTitleElementCSS: `body p.Text_20_body`,\n    stepTitleInSeparateContainer: false,\n    stepContainerElementNames:  [`div`],\n    stepTextElementNames: [],\n    stepTextElementClasses: [],\n    stepListElementNames: [`ol`, `ul`],\n    stepListItemElementClasses: [],\n    stepDefaultListType: `ol`,\n    stepIgnoreElementNames: [`img`],\n    tagMetaAttributeNames: [`keywords`, `dc.subject`]\n};\n\n// RUNBOOK_FILE_NAME: Target file name for the converted runbooks.\n// If the target file exists already, it is replaced without warning.\n// See actual definition below (we use different file names for different sample configurations)\n\n// RUNBOOK_NAME_SUFFIX: Optional suffix that gets appended to the name of each converted runbook.\n// See actual definition below (we use different values for different sample configurations)\n\n// ========= Alternative 1: READ FROM DIRECTORY =========\n// ROOT_URL: The directory where the source files are located\n// START_URL: If START_URL =  ROOT_URL, then the tool converts all *.htm/*html files from ROOT_URL\n//            If START_URL != ROOT_URL, then the tool converts the single file START_URL (for debugging and development)\n// DATA_URL: Equal to ROOT_URL\n// CRAWLER_DEPTH: Unused\n// LINK_ROOT_URL: URL prefix to be used in the runbook when relative links from the source document need to be converted\n//            to absolute links to the original location.\n// RUNBOOK_DEFAULT_TAGS: The list of default tags to be added to the converted runbooks\n// const ROOT_URL = `./sourceData/`;\n// const START_URL = ROOT_URL;\n// const DATA_URL = ROOT_URL;\n// const CRAWLER_DEPTH = 1;\n// const LINK_ROOT_URL = `https://en.wikipedia.org`;\n// const RUNBOOK_DEFAULT_TAGS = [`converted-html-local`];\n// const RUNBOOK_NAME_SUFFIX = ``;\n// const RUNBOOK_FILE_NAME = `runbooks.import.json`;\n// const RUNBOOK_PATTERNS = [PATTERN_STANDARD, PATTERN_MSO, PATTERN_TITLE_H1, PATTERN_H1_PARAGRAPH];\n\n// ========= Alternative 2: WEB/WIKI CRAWLER - Sample 1: Red Hat OpenShift Container Platform =========\n// ROOT_URL: The root URL that must be part of any URL that is considered during crawling, and while following links\n// START_URL: The first document to be evaluated\n// DATA_URL: Typically equal to ROOT_URL, but in some cases (like IBM Documentation) the\n//            actual data need to be retrieved from yet another content API URL (in the browser, this kind of URL forwarding\n//            is handled automatically, but some extra effort is needed for this crawler).\n//            In this case, the DATA_URL is identical to the ROOT_URL.\n// CRAWLER_DEPTH: The maximum depth for following links. Start with a low value (e.g., 3) and inspect the result data.\n//            Once you are satisfied with the quality of the result data, increase this value as appropriate.\n//            With CRAWLER_DEPTH = 3, this configuration generates 12 runbooks (as of 2022-03-01).\n// LINK_ROOT_URL: URL prefix to be used in the runbook when relative links from the source document need to be converted\n//            to absolute links to the original location.\n//            In this case, the LINK_ROOT_URL is identical to the ROOT_URL.\n// RUNBOOK_DEFAULT_TAGS: The list of default tags to be added to the converted runbooks\n//   === DISCLAIMER for converting pages from IBM documentation or Red Hat documentation ===\n//     Note that the internal structure of documentation pages may change at any time without notice.\n//     If you observe that the tool does not create reasonable output, then most likely the internal structure\n//     has changed.\n//     In this case, you should change this configuration file and start using Wikipedia as sample input:\n//          - disable section \"Alternative 2: WEB/WIKI CRAWLER - Sample 1: Red Hat OpenShift Container Platform\"\n//          - enable section \"Alternative 2: WEB/WIKI CRAWLER - Sample 2: Wikipedia\"\nconst START_URL = `https://docs.openshift.com/container-platform/4.9/support/troubleshooting/troubleshooting-installations.html`;\nconst ROOT_URL = `https://docs.openshift.com/container-platform/4.9/support/troubleshooting`;\nconst DATA_URL = ROOT_URL;\nconst CRAWLER_DEPTH = 3;\nconst LINK_ROOT_URL = ROOT_URL;\nconst RUNBOOK_DEFAULT_TAGS = [`converted-ocp-troubleshooting`];\nconst RUNBOOK_NAME_SUFFIX = ` (from Red Hat OCP 4.9)`;\nconst RUNBOOK_FILE_NAME = `runbooks.ocp.docs.import.json`;\nconst RUNBOOK_PATTERNS = [PATTERN_STANDARD];\n\n// ========= Alternative 2: WEB/WIKI CRAWLER - Sample 2: Wikipedia =========\n// Disclaimer: Wikipedia is probably not really a source of very meaningful runbooks.\n//             This example is intended to demonstrate how the crawler and the conversion works,\n//             based on a website that is available to the public and that returns data very quickly.\n//             Once you feel comfortable with the conversion process, you can switch to using your\n//             own document source.\n// const START_URL = `https://en.wikipedia.org/wiki/Wikipedia:Wiki_Game`;\n// const ROOT_URL = `https://en.wikipedia.org/wiki`;\n// const DATA_URL = ROOT_URL;\n// const CRAWLER_DEPTH = 2;\n// const LINK_ROOT_URL = `https://en.wikipedia.org`;\n// const RUNBOOK_DEFAULT_TAGS = [`converted-html-wikipedia`];\n// const RUNBOOK_NAME_SUFFIX = ` (from Wikipedia)`;\n// const RUNBOOK_FILE_NAME = `runbooks.wikipedia.import.json`;\n// const RUNBOOK_PATTERNS = [PATTERN_STANDARD];\n\n// ========= Additional configuration =========\n// The directory where the JSON file that contains the converted runbooks (RUNBOOK_FILE_NAME) should be written to.\n// If needed, the directory is created by the tool.\nconst RUNBOOK_DIRECTORY = `./resultData`;\n\n// Prefix for the reference to the source document, as it is added to the runbook description.\n// You can replace the string with your preferred localized string.\nconst SOURCE_REFERENCE_STRING = `Source`;\n\n// Optional: For each runbook, add a first step that explains that this runbook has been\n// converted and should be validated first, before it is published and ready to be used\n// in production.\n// Set \"includeStep\" to \"false\" if you do not want the disclaimer to be added to each runbook.\n// You can adjust the stepTitle and the stepDescription as needed for your organization.\nconst RUNBOOK_DISCLAIMER_STEP = {\n    includeStep: true,\n    includeListOfImages: true,\n    stepTitle: `DISCLAIMER`,\n    stepDescription: `This runbook has been generated from $$SOURCE$$ and should be reviewed before it\n        is used in production. Once you have validated the content and the format of this runbook, you\n        can remove this step and publish the runbook.`,\n    stepDescriptionImages: `The source document contains $$SOURCE_NUM_IMAGES$$ images that have not been\n        copied into this runbook. You can add the images manually. Large image files should be reduced\n        in file size (e.g., by taking a screen shot), as runbooks must have a total size of at most 1 MB.\n        This is the list of images in the source document: $$SOURCE_IMAGES_LIST$$`\n};\n\n// If any of the following strings appears at the beginning of an element that is considered as a list item,\n// then the list is interpreted as an unordered list.\nconst BULLET_ITEM_INDICATORS = [`&lt;B7&gt;`, `�`, `•`, `►`];\n\n// Remove all matches to the following regex patterns from all step descriptions within the generated runbooks.\n// For example, eliminate all &lt;span&gt; elements that just contain a bullet item or an ordinal number:\n// - Unordered lists are bulleted automatically, so we want to avoid having duplicate bullets.\n// - Similarly for ordered lists, we want to avoid duplicate numberings.\n// Also, eliminate all empty paragraphs.\nconst HTML_SANITIZE_PATTERNS = [\n    /&lt;span&gt;•&lt;\\/span&gt;/g,\n    /&lt;span&gt;([0-9])+\\.&lt;\\/span&gt;/g,\n    /&lt;p&gt;\\s*&lt;\\/p&gt;/g\n];\n\n// Crawler HTTP load and performance: Allows to throttle the load on the network\nconst MINIMUM_HTTP_PAUSE = 500;\nconst MAXIMUM_PARALLEL_REQUESTS = 100;\n\n// WEB/WIKI CRAWLER\n// For pages from the public internet, it is typically not needed to specify additional request headers.\n// However, for intranet pages, some kind of authentication token is required.\n// A missing authentication token may result in a response like: \"302 Found\".\n// To find the request options that you need to access your intranet pages:\n// - Open a new private browser window and open one of the wiki pages in the browser.\n// - This causes a redirect to the login page.\n// - After login, the required data are available within the browser cookies.\n// - Copy the cookies and other required header data from the browser into the HTTPS_REQUEST_OPTIONS object,\n//   and run the conversion tool (but note that typically the cookies need to be refreshed regularly).\n// - Feel free to replace this simple mechanism in the source code of this tool by a better login mechanism\n//   (e.g., using basic auth) as appropriate for your organization.\nconst HTTPS_REQUEST_OPTIONS = {};\n// const HTTPS_REQUEST_OPTIONS = {\n//     headers: {\n//         \"User-Agent\": `Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:86.0) Gecko/20100101 Firefox/86.0`,\n//         \"Accept\": `text/html`,\n//         \"Referer\": `&lt;InsertYourIntranetLoginRefererHere&gt;`,\n//         \"Cookie\": `session=********; xxx=********`\n//     },\n// };\n\n// Verbosity of diagnostic output\nconst INFO = true;\nconst DEBUG = true;\nconst DEBUG_RAW_DATA = true;\n\nmodule.exports = {\n    BULLET_ITEM_INDICATORS,\n    CRAWLER_DEPTH,\n    HTTPS_REQUEST_OPTIONS,\n    MINIMUM_HTTP_PAUSE,\n    MAXIMUM_PARALLEL_REQUESTS,\n    RUNBOOK_DEFAULT_TAGS,\n    RUNBOOK_DISCLAIMER_STEP,\n    RUNBOOK_DIRECTORY,\n    RUNBOOK_NAME_SUFFIX,\n    RUNBOOK_FILE_NAME,\n    RUNBOOK_PATTERNS,\n    ROOT_URL,\n    START_URL,\n    DATA_URL,\n    LINK_ROOT_URL,\n    SOURCE_REFERENCE_STRING,\n    HTML_SANITIZE_PATTERNS,\n    DEBUG,\n    DEBUG_RAW_DATA,\n    INFO\n};\n</code></pre><p>&nbsp;</p>",
            "number": 3,
            "type": "manual"
        },
        {
            "title": "File: crawler.js",
            "description": "<pre><code class=\"language-plaintext\">/*\n * crawler.js\n * Data conversion tool for runbooks (RBA).\n * This tool converts HTML sources (website or local files)\n * into runbooks in the RBA import format.\n * Requires: node (node.js runtime)\n * Version: 1\n * Date: 2022-02-04\n * Author: IBM\n * © Copyright IBM Corp. 2021, 2022  All Rights Reserved.\n * Use as is - no support\n */\n\n/* eslint-disable no-console */\n\nconst { JSDOM } = require(`jsdom`);\nconst { https } = require(`follow-redirects`);\nconst { Link, linkFromHTML } = require(`./Link.js`);\nconst { MINIMUM_HTTP_PAUSE, MAXIMUM_PARALLEL_REQUESTS, CRAWLER_DEPTH, ROOT_URL, START_URL, DATA_URL, RUNBOOK_DIRECTORY,\n    RUNBOOK_FILE_NAME, INFO, DEBUG, HTTPS_REQUEST_OPTIONS, DEBUG_RAW_DATA, LINK_ROOT_URL } = require(`./config.js`);\nconst { convertToRunbook } = require(`./parser.js`);\nconst fs = require(`fs`);\n\n// If needed, write the raw html data to console log and pass it to the resolve() function\nfunction handleRawData(data, responseUrl, resolve) {\n    if (DEBUG_RAW_DATA) {\n        console.log(`---------------- DATA BEGIN (source: ${responseUrl})-------------`);\n        console.log(data);\n        console.log(`---------------- DATA END -------------------------------------------\\n`);\n\n        // If DEBUG_RAW_DATA is enabled and CRAWLER_DEPTH = 1:\n        // Single page, can be stored in a file for further analysis (more convenient than the console output)\n        if (CRAWLER_DEPTH === 1) {\n            const tempFileName = `./temp.source.raw.html`;\n            try {\n                fs.writeFileSync(tempFileName, data, {encoding: `utf8`});\n            } catch (error) {\n                console.log(`ERROR while trying to write to file ${tempFileName}: ${error}`);\n            }\n        }\n    }\n    resolve(data);\n}\n\n// Get the data from the given link location\nfunction httpRequester(link) {\n    return new Promise((resolve) =&gt; {\n        setTimeout(() =&gt; {\n            https.get(link.url, HTTPS_REQUEST_OPTIONS, (res) =&gt; {\n                let data = ``;\n                res.on(`data`, (chunk) =&gt; {\n                    data += chunk;\n                });\n                res.on(`end`, () =&gt; {\n                    // The follow-redirects package sets the \"res.responseUrl\" property\n                    if (DEBUG) console.log(`httpRequester: *  url         = ${link.url}`);\n                    if (DEBUG) console.log(`httpRequester: -&gt; responseUrl = ${res.responseUrl}`);\n\n                    // If needed, get the actual data from the DATA_URL\n                    if (res.responseUrl &amp;&amp; res.responseUrl.startsWith(ROOT_URL) &amp;&amp; ROOT_URL !== DATA_URL) {\n                        // Remember the page (responseUrl) where we have been redirected to\n                        link.responseUrl = res.responseUrl;\n\n                        // Get the actual page content\n                        const dataProviderUrl = res.responseUrl.replace(ROOT_URL, DATA_URL);\n                        if (DEBUG) console.log(`httpRequester: -&gt; providerUrl = ${dataProviderUrl}`);\n                        https.get(dataProviderUrl, HTTPS_REQUEST_OPTIONS, (res2) =&gt; {\n                            let data2 = ``;\n                            res2.on(`data`, (chunk2) =&gt; {\n                                data2 += chunk2;\n                            });\n                            res2.on(`end`, () =&gt; {\n                                handleRawData(data2, res2.responseUrl, resolve);\n                            });\n                        });\n                    }\n                    else {\n                        handleRawData(data, res.responseUrl, resolve);\n                    }\n                });\n            });\n        }, MINIMUM_HTTP_PAUSE);\n    });\n}\n\n// Collect all links from the given bodyDocument. These are the candidates for the next level of depth\n// of web crawling.\nfunction getForwardLinks(bodyDocument) {\n    return Array.from(bodyDocument.querySelectorAll(`a`)).filter(el =&gt; el.getAttribute(`href`));\n}\n\n// Crawl over the given chunk of links for the current level of depth of web crawling.\nasync function crawlSingleChunk(chunkLinks, linkUrls, newLinks, newLinkUrls, linkUrlsChecked, titleList, runbooks) {\n    let promises;\n    let chunkHtmls;\n\n    // Load html data for chunk\n    try {\n        promises = chunkLinks.map(link =&gt; httpRequester(link));\n        chunkHtmls = await Promise.all(promises);\n    } catch (err) {\n        console.err(err.message);\n    }\n\n    // Merge html data with links\n    chunkLinks = chunkLinks.map((el, index) =&gt; {\n        const newEl = el;\n        newEl.bodyHtml = chunkHtmls[index];\n        return newEl;\n    }).filter(el =&gt; el.bodyHtml);\n\n    // Remember the forward links from the source documents (for the next level of depth of web crawling)\n    // eslint-disable-next-line no-loop-func\n    chunkLinks.forEach((link) =&gt; {\n        const bodyDocument = (new JSDOM(link.bodyHtml)).window.document;\n\n        // Add any available link for next iteration\n        getForwardLinks(bodyDocument).forEach((el) =&gt; {\n            try {\n                // Accept links that start with LINK_ROOT_URL but not with ROOT_URL only if some redirect\n                // is expected to occur, i.e., if LINK_ROOT_URL and ROOT_URL are not substrings of each other\n                const isRedirectAllowed = !ROOT_URL.startsWith(LINK_ROOT_URL) &amp;&amp; !LINK_ROOT_URL.startsWith(ROOT_URL);\n\n                const newForwardLink = linkFromHTML(el);\n                let ignoreReason = ``;\n                if (newForwardLink.url.startsWith(ROOT_URL) || (isRedirectAllowed &amp;&amp; newForwardLink.url.startsWith(LINK_ROOT_URL))) {\n                    if (!newLinkUrls.includes(newForwardLink.url)) {\n                        if (!linkUrlsChecked.includes(newForwardLink.url)) {\n                            if (!linkUrls.includes(newForwardLink.url)) {\n                                if (DEBUG) console.log(`crawlSingleChunk: adding forward link: ${newForwardLink.url}`);\n                                newLinks.push(newForwardLink);\n                                newLinkUrls.push(newForwardLink.url);\n                            }\n                            else {\n                                ignoreReason = `already contained in linkUrls`;\n                            }\n                        }\n                        else {\n                            ignoreReason = `already contained in linkUrlsChecked`;\n                        }\n                    }\n                    else {\n                        ignoreReason = `already contained in newLinkUrls`;\n                    }\n                }\n                else {\n                    ignoreReason = `URL does not start with ROOT_URL or LINK_ROOT_URL`;\n                }\n                if (ignoreReason.length &gt; 0) {\n                    if (DEBUG) console.log(`crawlSingleChunk: ignoring forward link: ${el.href} - ${newForwardLink.url}, reason: ${ignoreReason}`);\n                }\n            } catch (err) {\n                console.warn(`Error with link URL ${el.href}: ${err.stack}`);\n            }\n        });\n\n        // Try to convert this bodyDocument to a runbook and add it to \"runbooks\"\n        convertToRunbook(bodyDocument, link, linkUrlsChecked, titleList, runbooks);\n    });\n}\n\n// Root function for web crawling\nasync function proceduralCrawl(initialLink) {\n    let links = [initialLink];\n    let linkUrls = links.map(l =&gt; l.url);\n    const runbooks = [];\n\n    // Monitoring: Remember which links and runbook titles we have included already, to avoid duplicates\n    const linkUrlsChecked = [];\n    const titleList = [];\n\n    /* eslint-disable no-await-in-loop */\n    for (let curDepth = 1; (curDepth &lt;= CRAWLER_DEPTH) &amp;&amp; (links.length &gt; 0); curDepth += 1) {\n        // Generate chunks from links\n        const chunks = links.reduce((arr, el) =&gt; {\n            const newArray = arr;\n            if (arr[arr.length - 1].length &lt; MAXIMUM_PARALLEL_REQUESTS) {\n                newArray[arr.length - 1].push(el);\n            } else {\n                newArray.push([el]);\n            }\n            return newArray;\n        }, [[]]);\n\n        // Initiate array to save new links for next iteration\n        const newLinks = [];\n        const newLinkUrls = [];\n\n        // eslint-disable-next-line no-loop-func\n        // Execute crawling for every chunk\n        for (let i = 0; i &lt; chunks.length; i += 1) {\n            await crawlSingleChunk(chunks[i], linkUrls, newLinks, newLinkUrls, linkUrlsChecked, titleList, runbooks);\n            if (INFO) console.log(`Depth ${curDepth} of ${CRAWLER_DEPTH} - chunk ${i + 1} of ${chunks.length} done - runbooks found so far: ${runbooks.length}`);\n        }\n        // All chunks are finished - save new links for next iteration\n        if (DEBUG) console.log(`newLinks: ${newLinks.length}`);\n        if (DEBUG) console.log(`newLinkUrls: ${newLinkUrls.length}`);\n        links = newLinks;\n        linkUrls = newLinkUrls;\n    }\n    if (DEBUG) console.log(`Runbooks: ${JSON.stringify(runbooks, null, 4)}`);\n    if (INFO) console.log(`Runbooks created: ${runbooks.length}`);\n    /* eslint-enable no-await-in-loop */\n    return runbooks;\n}\n\n// Retrieve file names for directory crawling\nfunction getHtmlFileNames(rootDir, startDirOrFile) {\n    const rootDirWithSlash = (rootDir.endsWith(`/`)) ? rootDir : `${rootDir}/`;\n    let htmlFileNames = [];\n    if (rootDir === startDirOrFile) {\n        try {\n            htmlFileNames = fs.readdirSync(rootDirWithSlash);\n            htmlFileNames = htmlFileNames.filter(fileName =&gt; (fileName.endsWith(`.htm`) || fileName.endsWith(`.html`)));\n            htmlFileNames = htmlFileNames.filter(fileName =&gt; (!fileName.startsWith(`~$`)));\n            htmlFileNames = htmlFileNames.map(fileName =&gt; rootDirWithSlash + fileName);\n        }\n        catch (error) {\n            console.log(`ERROR while reading ${rootDirWithSlash}: ${error}`);\n        }\n    }\n    else {\n        try {\n            const singleFileExists = fs.existsSync(startDirOrFile);\n            if (singleFileExists === true) {\n                htmlFileNames.push(startDirOrFile);\n            }\n            else {\n                console.log(`ERROR while searching for ${startDirOrFile}: File does not exist`);\n            }\n        }\n        catch (error) {\n            console.log(`ERROR while searching for ${startDirOrFile}: ${error}`);\n        }\n    }\n    return htmlFileNames;\n}\n\n// Get content of a file\nfunction readSourceFile(fileName) {\n    let sourceContent = null;\n    try {\n        sourceContent = fs.readFileSync(fileName, {encoding: `utf8`});\n    } catch (error) {\n        console.log(`ERROR: Cannot read source file ${fileName}: ${error}`);\n    }\n    return sourceContent;\n}\n\n// Root function for directory crawling\nasync function proceduralCrawlDirectory() {\n    const htmlFileNames = getHtmlFileNames(ROOT_URL, START_URL);\n\n    const runbooks = [];\n    const titleList = [];\n\n    htmlFileNames.forEach(htmlFileName =&gt; {\n        let sourceContent = readSourceFile(htmlFileName);\n        const link = new Link(htmlFileName, htmlFileName);\n        link.bodyHtml = sourceContent;\n\n        const linkUrlsChecked = [];\n        const bodyDocument = (new JSDOM(sourceContent)).window.document;\n        // Try to convert this bodyDocument to a runbook and add it to \"runbooks\"\n        convertToRunbook(bodyDocument, link, linkUrlsChecked, titleList, runbooks);\n    });\n\n    if (DEBUG) console.log(`Runbooks: ${JSON.stringify(runbooks, null, 4)}`);\n    if (INFO) console.log(`Runbooks created: ${runbooks.length}`);\n    return runbooks;\n}\n\n// Entry point for crawling: decides if web crawling or directory crawling is needed\nasync function crawl() {\n    let runbooks = [];\n    if (ROOT_URL.startsWith(`http://`) || ROOT_URL.startsWith(`https://`)) {\n        if (START_URL.startsWith(ROOT_URL)) {\n            const link = new Link(START_URL, ``);\n            runbooks = await proceduralCrawl(link);\n        }\n        else {\n            console.log(`ERROR: START_URL (${START_URL}) does not start with ROOT_URL (${ROOT_URL})`);\n        }\n    }\n    else {\n        runbooks = await proceduralCrawlDirectory();\n    }\n    return runbooks;\n}\n\n// Save the runbooks to the output file\nasync function saveRunbooks(runbooks) {\n    const runbookFilePath = `${RUNBOOK_DIRECTORY}/${RUNBOOK_FILE_NAME}`;\n    try {\n        fs.mkdirSync(RUNBOOK_DIRECTORY, {recursive: true});\n        fs.writeFileSync(runbookFilePath, JSON.stringify(runbooks, null, 4), {encoding: `utf8`});\n    } catch (error) {\n        console.log(`ERROR while trying to write to file ${runbookFilePath}: ${error}`);\n    }\n}\n\nmodule.exports = { crawl, saveRunbooks };\n</code></pre>",
            "number": 4,
            "type": "manual"
        },
        {
            "title": "File: index.js",
            "description": "<pre><code class=\"language-plaintext\">/*\n * index.js\n * Data conversion tool for runbooks (RBA).\n * This tool converts HTML sources (website or local files)\n * into runbooks in the RBA import format.\n * Requires: node (node.js runtime)\n * Version: 1\n * Date: 2022-02-04\n * Author: IBM\n * © Copyright IBM Corp. 2021, 2022  All Rights Reserved.\n * Use as is - no support\n */\n\nconst crawler = require(`./crawler`);\n\n// Do the async crawling, and save the converted data to a JSON file\n(async () =&gt; {\n    const runbooks = await crawler.crawl();\n    crawler.saveRunbooks(runbooks);\n})();\n</code></pre>",
            "number": 5,
            "type": "manual"
        },
        {
            "title": "File: Link.js",
            "description": "<pre><code class=\"language-plaintext\">/*\n * Link.js\n * Data conversion tool for runbooks (RBA).\n * This tool converts HTML sources (website or local files)\n * into runbooks in the RBA import format.\n * Requires: node (node.js runtime)\n * Version: 1\n * Date: 2022-03-01\n * Author: IBM\n * © Copyright IBM Corp. 2021, 2022  All Rights Reserved.\n * Use as is - no support\n */\n\n/* eslint-disable no-console */\n\nconst { LINK_ROOT_URL } = require(`./config.js`);\n\nclass Link {\n    constructor(url, name) {\n        this.url = url;\n        this.responseUrl = ``;\n        this.pageRoot = ``;\n        this.bodyHtml = ``;\n        this.name = name || `Unnamed runbook link`;\n    }\n\n    // The pageRoot is the responseUrl without the very last path section (file).\n    // The pageRoot is needed for building the absolute URL based on a relative URL (href) found on a page.\n    // Perform lazy initialization of the pageRoot attribute.\n    // The check for \"?topic=\" is specific to the migration of the IBM Knowledge Center to IBM Documentation.\n    // If no meaningful pageRoot can be found (e.g., working on local files and not crawling a web site),\n    // then it defaults to the LINK_ROOT_URL.\n    getPageRoot() {\n        if (this.pageRoot.length === 0 &amp;&amp; this.responseUrl.length &gt; 0) {\n            const lastForwardSlashIndex = this.responseUrl.lastIndexOf(`/`);\n            const topicQueryIndex = this.responseUrl.indexOf(`?topic=`);\n            if (topicQueryIndex &gt; 0) {\n                // There is a \"topic\" query, so check if the last forward slash exists after that query\n                if (lastForwardSlashIndex &gt; topicQueryIndex) {\n                    this.pageRoot = this.responseUrl.substring(0, lastForwardSlashIndex);\n                }\n                // Otherwise: use the fallback\n            }\n            else {\n                // There is no \"topic\" query, so start at the last forward slash\n                this.pageRoot = this.responseUrl.substring(0, lastForwardSlashIndex);\n            }\n        }\n\n        // Fallback: Use LINK_ROOT_URL\n        if (this.pageRoot.length === 0) {\n            this.pageRoot = LINK_ROOT_URL;\n        }\n\n        return this.pageRoot;\n    }\n}\n\n// Convert the given HTML linkElement to a link with an absolute URL\nfunction linkFromHTML(linkElement) {\n    let newUrl = linkElement.href;\n\n    // Ignore the hash part of the URL\n    newUrl = newUrl.replace(/#.*/, ``);\n\n    // Replace relative URL with absolute URL, based on the LINK_ROOT_URL\n    if (!newUrl.startsWith(`http`)) {\n        if (newUrl.startsWith(`/`)) {\n            newUrl = `${LINK_ROOT_URL}${newUrl}`;\n        }\n        else {\n            newUrl = `${LINK_ROOT_URL}/${newUrl}`;\n        }\n    }\n\n    // Eliminate changing to the parent directory, which may bypass the LINK_ROOT_URL.\n    // Repeat this until no more \"../\" substrings are found in newUrl.\n    for (let previousUrl = ``; previousUrl !== newUrl; ) {\n        previousUrl = newUrl;\n        newUrl = newUrl.replace(/\\/[^/]+\\/\\.\\.\\//g, `/`);\n    }\n\n    return new Link(newUrl, linkElement.textContent);\n}\n\nmodule.exports = {\n    Link,\n    linkFromHTML,\n};\n</code></pre>",
            "number": 6,
            "type": "manual"
        },
        {
            "title": "File: package.json",
            "description": "<pre><code class=\"language-plaintext\">{\n  \"name\": \"convert-html-into-runbooks\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Creates runbooks from HTML sources\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"start\": \"node --max-old-space-size=8192 index.js\",\n    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n  },\n  \"author\": \"\",\n  \"dependencies\": {\n    \"follow-redirects\": \"^1.13.3\",\n    \"jsdom\": \"^16.6.0\"\n  },\n  \"devDependencies\": {}\n}\n</code></pre>",
            "number": 7,
            "type": "manual"
        },
        {
            "title": "File: parser.js",
            "description": "<pre><code class=\"language-plaintext\">/*\n * parser.js\n * Data conversion tool for runbooks (RBA).\n * This tool converts HTML sources (website or local files)\n * into runbooks in the RBA import format.\n * Requires: node (node.js runtime)\n * Version: 1\n * Date: 2022-02-04\n * Author: IBM\n * © Copyright IBM Corp. 2021, 2022  All Rights Reserved.\n * Use as is - no support\n */\n\n/* eslint-disable no-console */\n\nconst { sanitizeString, shortenString } = require(`./utils.js`);\nconst { Runbook } = require(`./Runbook.js`);\nconst { RUNBOOK_PATTERNS, RUNBOOK_DEFAULT_TAGS, DEBUG, BULLET_ITEM_INDICATORS,\n    HTML_SANITIZE_PATTERNS } = require(`./config.js`);\n\n// Supported list types are \"ol\" and \"ul\"\nfunction getListType(itemText, pattern) {\n    let containsBullet = false;\n    for (let i = 0; i &lt; BULLET_ITEM_INDICATORS.length; i++) {\n        const indicator = BULLET_ITEM_INDICATORS[i];\n        if (itemText.startsWith(indicator)) {\n            containsBullet = true;\n            break;\n        }\n    }\n    return containsBullet ? `ul` : pattern.stepDefaultListType;\n}\n\n// Discard all runbook title candidates that contain items of pattern.titleIgnoreSubstrings\nfunction isTitleAccepted(title, pattern) {\n    let isOk = true;\n    for (let i = 0; i &lt; pattern.titleIgnoreSubstrings.length &amp;&amp; isOk === true; i++) {\n        const ignoreSubstring = pattern.titleIgnoreSubstrings[i];\n        isOk = (title.indexOf(ignoreSubstring) &lt; 0);\n    }\n    return isOk;\n}\n\n// Tags should be trimmed, lowercase, no blanks within (replace with dashes)\nfunction keywordToTag(keyword) {\n    let tag = (keyword) ? keyword.trim() : ``;\n    tag = tag.toLowerCase();\n    tag = tag.replace(/ /g, `-`);\n    return tag;\n}\n\n// Convert the keyword to a tag. If it is valid, then add it to the tags.\nfunction addToTags(keyword, tags) {\n    const tagCandidate = keywordToTag(keyword);\n    if (tagCandidate.length &gt; 0 &amp;&amp; !tags.includes(tagCandidate)) {\n        tags.push(tagCandidate);\n    }\n}\n\n// Convert the RUNBOOK_DEFAULT_TAGS to valid tags and return them\nfunction getDefaultTags() {\n    const defaultTags = [];\n    RUNBOOK_DEFAULT_TAGS.forEach(keyword =&gt; {\n        addToTags(keyword, defaultTags);\n    });\n    return defaultTags;\n}\n\n// Remove duplicate item indicators and whitespace from the itemText\nfunction sanitizeListItem(itemText) {\n    let sanitized = itemText || ``;\n\n    // Cut out all bullet item indicators\n    BULLET_ITEM_INDICATORS.forEach(bulletPattern =&gt; {\n        sanitized = sanitized.split(bulletPattern).join(``);\n    });\n\n    // Remove leading numbers from itemText\n    sanitized = sanitized.replace(/^([0-9])+\\.\\s*/, ``);\n\n    // Remove whitespace\n    return sanitizeString(sanitized);\n}\n\n// Convert the \"raw\" itemHtml to html format that is supported by the RBA UI\nfunction sanitizeHTML(itemHtml, pageRoot) {\n    let sanitized = itemHtml || ``;\n\n    // Replace relative links with absolute links, but avoid duplicate forward slashes\n    sanitized = sanitized.replace(/href=\"(?!http)/g, `href=\"${pageRoot}/`);\n    sanitized = sanitized.split(`href=\"${pageRoot}//`).join(`href=\"${pageRoot}/`);\n\n    // Remove all HTML classes and styles\n    sanitized = sanitized.replace(/(\\s(class|style)=\"[^\"]*\")/g, ``);\n\n    // Replace all sample code (&lt;samp&gt; or &lt;pre&gt;&lt;code&gt;) with code blocks that are supported by the RBA UI\n    sanitized = sanitized.replace(/(&lt;samp&gt;|&lt;pre&gt;\\s*&lt;code&gt;)/g, `&lt;pre&gt;&lt;code class=\"language-plaintext\"&gt;`);\n    sanitized = sanitized.replace(/(&lt;\\/samp&gt;)/g, `&lt;/code&gt;&lt;/pre&gt;`);\n\n    // Eliminate the matches to all patters in HTML_SANITIZE_PATTERNS\n    HTML_SANITIZE_PATTERNS.forEach(pattern =&gt; {\n        sanitized = sanitized.replace(pattern, ``);\n    });\n\n    return sanitized;\n}\n\n// Convert the given tableArea HTML element (\"thead\", \"tbody\", or \"tfoot\") to the table format\n// that is supported by RBA. Footers (\"tfoot\") are not supported by the RBA tables and are converted to \"tbody\".\n// For more details, see function sanitizeTableContent().\nfunction sanitizeTableArea(tableArea) {\n    let areaTypeName = tableArea.localName;\n    if (areaTypeName === `tfoot`) {\n        areaTypeName = `tbody`;\n        if (DEBUG) console.log(`sanitizeTableArea: Convert ${tableArea.localName} to ${areaTypeName}`);\n    }\n    if (DEBUG) console.log(`sanitizeTableArea (${areaTypeName}): ${shortenString(sanitizeString(tableArea.textContent), 60)}`);\n\n    const areaTypeFieldName = (areaTypeName === `thead`) ? `th` : `td`;\n\n    let areaContent = `&lt;${areaTypeName}&gt;`;\n    for (let i = 0; i &lt; tableArea.children.length; i++) {\n        const tableRow = tableArea.children[i];\n        // All of the children of tableArea are expected to be table rows (tr)\n        if (tableRow.localName === `tr`) {\n            areaContent += `&lt;tr&gt;`;\n            for (let j = 0; j &lt; tableRow.children.length; j++) {\n                const tableDefinition = tableRow.children[j];\n                if (tableDefinition.localName === `th` || tableDefinition.localName === `td`) {\n                    areaContent += `&lt;${areaTypeFieldName}&gt;${sanitizeString(tableDefinition.textContent)}&lt;/${areaTypeFieldName}&gt;`;\n                }\n                else {\n                    if (DEBUG) console.log(`sanitizeTableArea ignore: field (${tableDefinition.localName}): ${tableDefinition.textContent}`);\n                }\n            }\n            areaContent += `&lt;/tr&gt;`;\n        }\n        else {\n            areaContent += sanitizeTableOtherRow(tableRow);\n        }\n    }\n    areaContent += `&lt;/${areaTypeName}&gt;`;\n    return areaContent;\n}\n\n// If we encounter an unexpected element at the level of a table row or table area, then convert that to a simple\n// table row (to avoid dropping the content altogether).\nfunction sanitizeTableOtherRow(tableUnknownElement) {\n    if (DEBUG) console.log(`sanitizeTableOther (${tableUnknownElement.localName}): ${shortenString(tableUnknownElement.textContent, 60)}`);\n    return `&lt;tr&gt;&lt;td&gt;${sanitizeString(tableUnknownElement.textContent)}&lt;td&gt;&lt;/tr&gt;`;\n}\n\n// Only tables with the following formats are supported by this tool (and no further styles etc.):\n// &lt;table&gt;\n//   &lt;thead&gt;\n//     &lt;tr&gt;&lt;th&gt;Country&lt;/th&gt;&lt;th&gt;City&lt;/th&gt;&lt;th&gt;River&lt;/th&gt;&lt;th&gt;Size&lt;/th&gt;&lt;/tr&gt;\n//   &lt;/thead&gt;\n//   &lt;tbody&gt;\n//     &lt;tr&gt;&lt;td&gt;US&lt;/td&gt;&lt;td&gt;NY&lt;/td&gt;&lt;td&gt;Hudson&lt;/td&gt;&lt;td&gt;XL&lt;/td&gt;&lt;/tr&gt;\n//     &lt;tr&gt;&lt;td&gt;DE&lt;/td&gt;&lt;td&gt;Fra&lt;/td&gt;&lt;td&gt;Main&lt;/td&gt;&lt;td&gt;M&lt;/td&gt;&lt;/tr&gt;\n//   &lt;/tbody&gt;\n// &lt;/table&gt;\n// or\n// &lt;table&gt;\n//   &lt;tr&gt;&lt;td&gt;US&lt;/td&gt;&lt;td&gt;NY&lt;/td&gt;&lt;td&gt;Hudson&lt;/td&gt;&lt;td&gt;XL&lt;/td&gt;&lt;/tr&gt;\n//   &lt;tr&gt;&lt;td&gt;DE&lt;/td&gt;&lt;td&gt;Fra&lt;/td&gt;&lt;td&gt;Main&lt;/td&gt;&lt;td&gt;M&lt;/td&gt;&lt;/tr&gt;\n// &lt;/table&gt;\n// In case of the second format (without HTML groups), the HTML parser inserts a default \"tbody\" area\n// that encloses the &lt;tr&gt; elements, so we can assume \"tbody\" to exist even if this is not explicitly specified\n// in the source HTML code.\n// All content from the table header fields and from the table definition fields are just copied as plain text\n// (i.e., the textContent, without any further HTML formatting).\nfunction sanitizeTableContent(tableElement) {\n    let tableContent = `&lt;table&gt;`;\n    for (let i = 0; i &lt; tableElement.children.length; i++) {\n        const tableArea = tableElement.children[i];\n        if (tableArea.localName === `thead` || tableArea.localName === `tbody` || tableArea.localName === `tfoot`) {\n            tableContent += sanitizeTableArea(tableArea);\n        }\n        else if (tableArea.localName === `colgroup`) {\n            if (DEBUG) console.log(`sanitizeTableContent: ignoring column formatting (${tableArea.localName})`);\n        }\n        else {\n            tableContent += sanitizeTableOtherRow(tableArea);\n        }\n    }\n    tableContent += `&lt;/table&gt;`;\n    return tableContent;\n}\n\n// Step description snippets are used to collect the data that will end up in one runbook step.\n// In particular, the object remembers if we are currently evaluating a list, so we can finish the list\n// when an element is found that is not a list element any more.\n// This feature is not needed for HTML sources with \"proper\" HTML lists.\n// This feature is needed for some document formats that define lists implicitly (for example, see the\n// sample pattern PATTERN_MSO).\n// The \"pageRoot\" parameter needs to be used whenever converting a relative URL (from a href element)\n// to an absolute URL (because within the resulting runbook, the original relative URLs cannot be\n// resolved any more).\nfunction createStepDescriptionSnippet(pageRoot) {\n    // The listType indicates if we are currently collecting data for a list:\n    //   - empty string: no list started\n    //   - \"ul\": unordered list\n    //   - \"ol\": ordered list\n    return {\n        stepTitle: ``,\n        stepDescription: ``,\n        listType: ``,\n        pageRoot: pageRoot,\n        nextElement: null\n    };\n}\n\n// If the stepDescriptionSnippet indicates that a list is being evaluated, finish that list now\nfunction finishList(stepDescriptionSnippet) {\n    if (stepDescriptionSnippet.stepDescription.length &gt; 0 &amp;&amp; stepDescriptionSnippet.listType.length &gt; 0) {\n        // Finish the list\n        stepDescriptionSnippet.stepDescription = `${stepDescriptionSnippet.stepDescription}&lt;/${stepDescriptionSnippet.listType}&gt;`;\n        stepDescriptionSnippet.listType = ``;\n    }\n}\n\n// Convert the stepDescriptionSnippet to a step and add it to the list of steps\nfunction finishStep(stepDescriptionSnippet, steps) {\n    // If we could not find step content, then fall back to repeat the step title\n    // (instead of discarding this step)\n    if (stepDescriptionSnippet.stepDescription.length === 0) {\n        stepDescriptionSnippet.stepDescription = stepDescriptionSnippet.stepTitle;\n    }\n\n    finishList(stepDescriptionSnippet);\n\n    const step = {\n        title: sanitizeString(stepDescriptionSnippet.stepTitle),\n        description: sanitizeString(stepDescriptionSnippet.stepDescription),\n        number: steps.length + 1,\n        type: `manual`\n    };\n    steps.push(step);\n\n    if (DEBUG) console.log(`finishStep CREATED: ${JSON.stringify(step, null, 4)}`);\n}\n\n// Elements \"&lt;pre&gt;&lt;code&gt;\" and \"&lt;samp&gt;\" are both treated as code boxes\nfunction isCodeBox(htmlElement) {\n    let isCodeBox = false;\n    if (htmlElement.localName === `pre`) {\n        const children = htmlElement.children;\n        if (children &amp;&amp; children.length &gt; 0 &amp;&amp; children[0].localName === `code`) {\n            isCodeBox = true;\n        }\n    }\n    else if (htmlElement.localName === `samp`) {\n        isCodeBox = true;\n    }\n    if (DEBUG &amp;&amp; isCodeBox) console.log(`isCodeBox: ${htmlElement.localName} -&gt; ${isCodeBox}`);\n    return isCodeBox;\n}\n\n// The stepDescriptionSnippet.nextElement is a \"flat\" element (not a container and not a code box)\n// that needs to be added to the step content.\n// If there is a next sibling, this is recorded in the stepDescriptionSnippet by changing the nextElement property.\nfunction evaluateFlatElement(stepDescriptionSnippet, pattern) {\n    let stepDescription = stepDescriptionSnippet.stepDescription;\n    let listType = stepDescriptionSnippet.listType;\n    let currentElement = stepDescriptionSnippet.nextElement;\n    let nextSibling;\n    if (currentElement) {\n        if (pattern.stepListItemElementClasses.includes(currentElement.className)) {\n            if (listType.length === 0) {\n                // Start a list\n                listType = getListType(currentElement.textContent, pattern);\n                stepDescription += `&lt;${listType}&gt;`;\n            }\n            stepDescription += `&lt;li&gt;${sanitizeListItem(currentElement.textContent)}&lt;/li&gt;`;\n            nextSibling = currentElement.nextElementSibling;\n        }\n        else if (pattern.stepTextElementNames.includes(currentElement.localName)\n                || pattern.stepTextElementClasses.includes(currentElement.className)) {\n            if (listType.length &gt; 0) {\n                // Finish the list\n                stepDescription += `&lt;/${listType}&gt;`;\n                listType = ``;\n            }\n            const textContent = sanitizeString(currentElement.textContent);\n            if (textContent.length &gt; 0) {\n                // If there is no step title yet: use the textContent\n                if (stepDescriptionSnippet.stepTitle.length === 0) {\n                    stepDescriptionSnippet.stepTitle = textContent;\n                }\n                stepDescription += `&lt;p&gt;${textContent}&lt;/p&gt;`;\n            }\n            nextSibling = currentElement.nextElementSibling;\n        }\n        else if (pattern.stepListElementNames.includes(currentElement.localName)) {\n            // We get a complete list (ordered or unordered), just copy the complete html content\n            const sanitizedHTML = sanitizeHTML(currentElement.innerHTML, stepDescriptionSnippet.pageRoot);\n            stepDescription += `&lt;${currentElement.localName}&gt;${sanitizedHTML}&lt;/${currentElement.localName}&gt;`;\n            nextSibling = currentElement.nextElementSibling;\n        }\n        else if (currentElement.localName === `table`) {\n            const sanitizedTableContent = sanitizeTableContent(currentElement);\n            stepDescription += `&lt;figure class=\"table\"&gt;${sanitizedTableContent}&lt;/figure&gt;`;\n            nextSibling = currentElement.nextElementSibling;\n        }\n        else if (pattern.stepIgnoreElementNames.includes(currentElement.localName)) {\n            if (DEBUG) console.log(`evaluateFlatElement ignore: ${currentElement.localName}`);\n            stepDescription += `&lt;p&gt;WARNING: Element \"${currentElement.localName}\" has been skipped when this runbook was created.&lt;/p&gt;`;\n            nextSibling = currentElement.nextElementSibling;\n        }\n        else {\n            nextSibling = null;\n        }\n\n        stepDescriptionSnippet.stepDescription = stepDescription;\n        stepDescriptionSnippet.listType = listType;\n        stepDescriptionSnippet.nextElement = nextSibling;\n\n        if (DEBUG) console.log(`evaluateFlatElement UPDATED: ${JSON.stringify(stepDescriptionSnippet, null, 4)}`);\n    }\n    else {\n        if (DEBUG) console.log(`evaluateFlatElement SKIP: currentElement is undefined`);\n    }\n}\n\n// evaluateCodeBox\n// - Parameter codeBoxElement may be either \"pre\" (followed by \"code\") or \"samp\"\n// - The innerHTML requires extra handling, because the RBA UI does not support &lt;span&gt; elements.\n//   The RBA UI just supports plain text with \\n newline characters.\n// In many cases, this function creates more newlines than contained in the original page\n// (in case there should be multiple spans for a single line, as defined within the span-classes).\n// But there does not seem to be a generic solution for that problem, as we cannot simply predict\n// the span-classes and their meaning.\nfunction evaluateCodeBox(codeBoxElement, stepDescriptionSnippet) {\n    let codeBoxContent = ``;\n    let codeBoxWrapper = codeBoxElement;\n    if (codeBoxElement.localName === `pre`) {\n        // In this case, we have already verified that children[0] is a \"code\" element\n        codeBoxWrapper = codeBoxElement.children[0];\n    }\n    // else: codeBoxElement.localName === `samp`, and we do not need to skip the \"code\" element\n\n    const codeBoxContentElements = codeBoxWrapper.children;\n    for (let i = 0; i &lt; codeBoxContentElements.length; i++) {\n        const codeBoxContentElement = codeBoxContentElements[i];\n        codeBoxContent += codeBoxContentElement.textContent;\n        if (i &lt; codeBoxContentElements.length - 1) {\n            codeBoxContent += `&lt;CODE_BLOCK_NEWLINE&gt;`;\n        }\n    }\n\n    // Finally, ensure that we end up with a code block that the RBA UI understands\n    // Since \"&lt;samp&gt;\" will be converted to \"&lt;pre&gt;&lt;code&gt;\" anyway in sanitizeHTML(), we do not need to\n    // distinguish these cases here.\n    const sanitizedHTML = sanitizeHTML(`&lt;pre&gt;&lt;code&gt;${codeBoxContent}&lt;/pre&gt;&lt;/code&gt;`, stepDescriptionSnippet.pageRoot);\n    stepDescriptionSnippet.stepDescription += sanitizedHTML;\n    if (DEBUG) console.log(`evaluateCodeBox added: ${sanitizedHTML}`);\n}\n\n// Evaluate a container (\"div\") by further navigating into its children\nfunction evaluateContainer(containerElement, stepDescriptionSnippet, pattern) {\n    const containerChildren = containerElement.children;\n    for (let childNum = 0; childNum &lt; containerChildren.length; childNum++) {\n        const nextChild = containerChildren[childNum];\n        stepDescriptionSnippet.nextElement = nextChild;\n        if (DEBUG) console.log(`evaluateContainer nextChild (${childNum + 1}/${containerChildren.length}): ${nextChild.localName} (${nextChild.className})`);\n\n        if (pattern.stepContainerElementNames.includes(nextChild.localName)) {\n            // If a list has already been started, finish it now, before diving into the container\n            finishList(stepDescriptionSnippet);\n\n            // Recursively iterate over the children of this container\n            evaluateContainer(nextChild, stepDescriptionSnippet, pattern);\n        }\n        else if (isCodeBox(nextChild)) {\n            evaluateCodeBox(nextChild, stepDescriptionSnippet);\n        }\n        else {\n            evaluateFlatElement(stepDescriptionSnippet, pattern);\n        }\n    }\n    // If a list has been started, finish it now\n    finishList(stepDescriptionSnippet);\n}\n\n// This is a fallback to get text content for a step from its title, if no other text content could be found\nfunction extractTextContentOfParent(currentElement, stepTitle) {\n    let textContent = currentElement.parentElement.textContent;\n\n    // If possible, avoid to repeat the step title itself within the step description.\n    if (textContent &amp;&amp; textContent.startsWith(stepTitle)) {\n        textContent = textContent.substring(stepTitle.length);\n    }\n    if (DEBUG) console.log(`extractTextContentOfParent: ${textContent}`);\n    return textContent;\n}\n\n// Get all the runbook steps (according to the selected pattern) from the given bodyDocument\nfunction extractSteps(bodyDocument, pattern, link) {\n    const steps = [];\n\n    const stepTitleElements = Array.from(bodyDocument.querySelectorAll(pattern.stepTitleElementCSS));\n    if (DEBUG) console.log(`extractSteps: stepTitleCandidates = ${JSON.stringify(stepTitleElements.map(el =&gt; el.textContent))}`);\n    for (let stepNum = 0; stepNum &lt; stepTitleElements.length; stepNum++) {\n        const stepTitleElement = stepTitleElements[stepNum];\n        const stepTitle = stepTitleElement.textContent;\n\n        let stepDescriptionSnippet = createStepDescriptionSnippet(link.getPageRoot());\n        stepDescriptionSnippet.stepTitle = stepTitle;\n        if (pattern.stepTitleInSeparateContainer === true) {\n            // For example, this can be necessary for IBM Documentation articles: The step title is\n            // buried inside a container, and we have to step back to its parent to find the step\n            // description.\n            const stepTitleParent = stepTitleElement.parentElement;\n            stepDescriptionSnippet.nextElement = stepTitleParent.nextElementSibling;\n        }\n        else {\n            stepDescriptionSnippet.nextElement = stepTitleElement.nextElementSibling;\n        }\n\n        while (stepDescriptionSnippet.nextElement) {\n            let nextElement = stepDescriptionSnippet.nextElement;\n            if (DEBUG) {\n                let elementText = nextElement.textContent;\n                // If needed, shorten the elementText and remove some whitespace:\n                // this is just to give an idea which element we are looking at\n                elementText = shortenString(elementText, 40);\n                elementText = sanitizeString(elementText);\n                console.log(`extractSteps nextElement: ${nextElement.localName} (${nextElement.className}): ${elementText}`);\n            }\n            if (pattern.stepContainerElementNames.includes(nextElement.localName)) {\n                // If a list has already been started, finish it now, before diving into the container\n                finishList(stepDescriptionSnippet);\n\n                // Remember the next sibling of the container (if any)\n                const nextSibling = nextElement.nextElementSibling;\n\n                // Iterate over the children of this container\n                evaluateContainer(nextElement, stepDescriptionSnippet, pattern);\n                stepDescriptionSnippet.nextElement = nextSibling;\n            }\n            else if (isCodeBox(nextElement)) {\n                evaluateCodeBox(nextElement, stepDescriptionSnippet);\n                stepDescriptionSnippet.nextElement = nextElement.nextElementSibling;\n            }\n            else {\n                evaluateFlatElement(stepDescriptionSnippet, pattern);\n            }\n        }\n\n        // Fallback (currently limited to IBM Documentation, i.e., stepTitleInSeparateContainer === true):\n        // If we could not find any step content (i.e., stepDescriptionSnippet.stepDescription is still empty), then\n        // try to get the textContent of the parent or even the grand-parent of the title element.\n        // If possible, avoid to repeat the step title itself within the step description.\n        if (stepDescriptionSnippet.stepDescription.length === 0 &amp;&amp; pattern.stepTitleInSeparateContainer === true) {\n            let stepTextContent = extractTextContentOfParent(stepTitleElement, stepTitle);\n            if (stepTextContent.length === 0 || stepTextContent === stepTitle) {\n                stepTextContent = extractTextContentOfParent(stepTitleElement.parentElement, stepTitle);\n            }\n            stepDescriptionSnippet.stepDescription = stepTextContent;\n        }\n\n        finishStep(stepDescriptionSnippet, steps);\n    }\n\n    return steps;\n}\n\n// Get the description for the complete runbook (not for an individual step).\n// Note: This description will be modified later to include the link to the source document,\n// and to stay within the limit of 300 characters for the description.\nfunction extractDescription(startElement, pattern) {\n    if (DEBUG) console.log(`extractDescription ENTRY: ${startElement ? startElement.localName : `null`}`);\n    let description = ``;\n    let nextSibling = startElement;\n    while (nextSibling) {\n        let nextDescriptionSnippet = ``;\n        if ((pattern.descriptionElementNames.includes(nextSibling.localName) &amp;&amp; nextSibling.className.length === 0)\n            || pattern.descriptionElementClasses.includes(nextSibling.className)) {\n            nextDescriptionSnippet = nextSibling.textContent;\n            nextSibling = nextSibling.nextElementSibling;\n        }\n        // Navigate into div-container only if we did not find anything yet\n        else if (description.length === 0 &amp;&amp; nextSibling.localName === `div`) {\n            const containerChildren = nextSibling.children;\n            for (let i = 0; i &lt; containerChildren.length; i++) {\n                const childElement = containerChildren[i];\n                nextDescriptionSnippet = extractDescription(childElement, pattern);\n                if (nextDescriptionSnippet.length &gt; 0) {\n                    // Stop if we have found something\n                    break;\n                }\n            }\n            // Stop if we have found something\n            nextSibling = (nextDescriptionSnippet.length &gt; 0) ? null : nextSibling.nextElementSibling;\n        }\n        else {\n            nextSibling = null;\n        }\n\n        if (nextDescriptionSnippet.length &gt; 0) {\n            if (description.length &gt; 0) {\n                description += ` `;\n            }\n            description += nextDescriptionSnippet;\n        }\n    }\n    description = sanitizeString(description);\n    if (DEBUG) console.log(`extractDescription RETURN: ${description}`);\n    return description;\n}\n\n// Get the tags for the runbook, including the default tags.\nfunction extractTags(bodyDocument, pattern) {\n    const tags = getDefaultTags();\n\n    const tagAttributeNames = pattern.tagMetaAttributeNames;\n    const metas = bodyDocument.getElementsByTagName(`meta`);\n    for (let i = 0; i &lt; metas.length; i++) {\n        const metaElement = metas[i];\n        if (metaElement.getAttribute(`name`)) {\n            if (tagAttributeNames.includes(metaElement.getAttribute(`name`).toLowerCase())) {\n                const content = metaElement.getAttribute(`content`);\n                content.split(`,`).forEach((keyword) =&gt; { addToTags(keyword, tags); });\n            }\n        }\n    }\n\n    return tags;\n}\n\n// Get the image names from the source document\nfunction extractImageNames(bodyDocument) {\n    let imageNames = [];\n\n    const images = Array.from(bodyDocument.querySelectorAll(`img`));\n    for (let i = 0; i &lt; images.length; i++) {\n        const imageName = images[i].getAttribute(`src`);\n        if (imageName) {\n            imageNames.push(imageName);\n        }\n    }\n\n    return imageNames;\n}\n\n// Entry point to try to convert the given bodyDocument to a runbook, and add it to runbooks.\nfunction convertToRunbook(bodyDocument, link, linkUrlsChecked, titleList, runbooks) {\n    let title = ``;\n    let description = ``;\n    let steps = [];\n    let tags;\n\n    // Find out which pattern to use: Take first pattern that yields a title and some steps\n    for (let patternIndex = 0; patternIndex &lt; RUNBOOK_PATTERNS.length; patternIndex++) {\n        const pattern = RUNBOOK_PATTERNS[patternIndex];\n        const titleElementCandidates = Array.from(bodyDocument.querySelectorAll(pattern.titleElementCSS));\n        if (DEBUG) console.log(`convertToRunbook [pattern ${patternIndex}]: ${link.url} -&gt; titleElementCandidates = ${JSON.stringify(titleElementCandidates.map(el =&gt; el.textContent))}`);\n\n        for (let titleCandidateIndex = 0; titleCandidateIndex &lt; titleElementCandidates.length; titleCandidateIndex++) {\n            const titleElementCandidate = titleElementCandidates[titleCandidateIndex];\n            title = sanitizeString(titleElementCandidate.textContent);\n            if (isTitleAccepted(title, pattern)) {\n                if (DEBUG) console.log(`convertToRunbook [pattern ${patternIndex}]: try ${link.url} (title candidate = ${title})`);\n                steps = extractSteps(bodyDocument, pattern, link);\n                if (steps.length &gt; 0) {\n                    // Found the right pattern that yields some steps... now get the description as well,\n                    // from the next sibling of the title candidate\n                    description = extractDescription(titleElementCandidate.nextElementSibling, pattern);\n                    tags = extractTags(bodyDocument, pattern);\n                    break;\n                }\n            }\n            else {\n                if (DEBUG) console.log(`convertToRunbook [pattern ${patternIndex}]: title candidate not accepted: ${title}`);\n            }\n        }\n        if (steps.length &gt; 0) break;\n    }\n\n    if (title &amp;&amp; tags &amp;&amp; steps.length &gt; 0 &amp;&amp; !titleList.includes(title)) {\n        const imageNames = extractImageNames(bodyDocument);\n        runbooks.push(new Runbook(title, description, tags, steps, link, imageNames));\n        titleList.push(title);\n    }\n    else {\n        if (DEBUG) console.log(`convertToRunbook: IGNORE ${title}::${description}::${steps.length}`);\n    }\n\n    linkUrlsChecked.push(link.url);\n}\n\nmodule.exports = {\n    convertToRunbook\n};\n</code></pre>",
            "number": 8,
            "type": "manual"
        },
        {
            "title": "File: Runbook.js",
            "description": "<pre><code class=\"language-plaintext\">/*\n * Runbook.js\n * Data conversion tool for runbooks (RBA).\n * This tool converts HTML sources (website or local files)\n * into runbooks in the RBA import format.\n * Requires: node (node.js runtime)\n * Version: 1\n * Date: 2022-02-04\n * Author: IBM\n * © Copyright IBM Corp. 2021, 2022  All Rights Reserved.\n * Use as is - no support\n */\n\nconst { RUNBOOK_DISCLAIMER_STEP, SOURCE_REFERENCE_STRING, ROOT_URL, RUNBOOK_NAME_SUFFIX } = require(`./config.js`);\nconst { sanitizeString, shortenString } = require(`./utils.js`);\n\nclass Runbook {\n    constructor(name, description, tags, steps, link, imageNames) {\n        // If the link.url has been redirected to a new page link.responseUrl, store the link.responesUrl in the runbook\n        const linkUrl = (link.responseUrl &amp;&amp; link.responseUrl.length &gt; 0) ? link.responseUrl : link.url;\n\n        this.name = `${name}${RUNBOOK_NAME_SUFFIX}`;\n        this.description = buildDescription(description, linkUrl);\n        this.steps = [];\n        let stepNum = 0;\n\n        // Insert optional generic step as hint that the runbook has been generated,\n        // and has not yet been validated\n        if (RUNBOOK_DISCLAIMER_STEP.includeStep === true) {\n            const isWeb = (ROOT_URL.startsWith(`http://`) || ROOT_URL.startsWith(`https://`));\n            const linkHtml = isWeb ? `&lt;a target=\"_blank\" rel=\"noopener noreferrer\" href=\"${linkUrl}\"&gt;${linkUrl}&lt;/a&gt;` : linkUrl;\n            let stepDescr = RUNBOOK_DISCLAIMER_STEP.stepDescription.replace(`$$SOURCE$$`, linkHtml);\n\n            // If needed, add a section that includes the names of all images from the source document\n            if (RUNBOOK_DISCLAIMER_STEP.includeListOfImages === true &amp;&amp; imageNames &amp;&amp; imageNames.length &gt; 0) {\n                // Convert the array imageNames to an unordered list\n                let imageNameList = `&lt;ul&gt;`;\n                for (let i = 0; i &lt; imageNames.length; i++) {\n                    imageNameList += `&lt;li&gt;${imageNames[i]}&lt;/li&gt;`;\n                }\n                imageNameList += `&lt;/ul&gt;`;\n\n                let imagesDescr = RUNBOOK_DISCLAIMER_STEP.stepDescriptionImages.replace(`$$SOURCE_NUM_IMAGES$$`, imageNames.length);\n                imagesDescr = imagesDescr.replace(`$$SOURCE_IMAGES_LIST$$`, imageNameList);\n                stepDescr += `&lt;br&gt;${imagesDescr}`;\n            }\n\n            this.steps.push({\n                number: stepNum += 1,\n                title: RUNBOOK_DISCLAIMER_STEP.stepTitle,\n                description: sanitizeString(stepDescr),\n                type: `manual`\n            });\n        }\n\n        steps.forEach((step) =&gt; {\n            if (typeof step === `string`) {\n                this.steps.push({\n                    number: stepNum += 1,\n                    title: shortenStepTitle(step),\n                    description: step,\n                    type: `manual`\n                });\n            }\n            else {\n                if (step.description.length === 0) {\n                    step.description = step.title;\n                }\n                step.title = shortenStepTitle(step.title);\n                step.number = stepNum += 1;\n                this.steps.push(step);\n            }\n        });\n        this.tags = [];\n        tags.forEach((tag) =&gt; {\n            const trimmedTag = tag.trim();\n            this.tags.push(trimmedTag.length &gt; 30 ? trimmedTag.substring(0, 30).trim() : trimmedTag);\n        });\n    }\n}\n\nfunction shortenStepTitle(rawStepTitle) {\n    // The maximum length for the step title has been proven to be a good guess (may be modified)\n    const MAX_STEP_TITLE_LEN = 180;\n    let stepTitle = rawStepTitle;\n    const paragraphStartIndex = rawStepTitle.indexOf(`&lt;p&gt;`) + 3;\n    const paragraphStopIndex = rawStepTitle.indexOf(`&lt;/p&gt;`);\n    if (paragraphStartIndex &gt; -1 &amp;&amp; paragraphStopIndex &gt; paragraphStartIndex) {\n        stepTitle = rawStepTitle.substring(paragraphStartIndex, paragraphStopIndex);\n    }\n    stepTitle = shortenString(stepTitle, MAX_STEP_TITLE_LEN);\n    return stepTitle;\n}\n\nfunction buildDescription(rawDescription, linkUrl) {\n    // The total length of the runbook description must be 300 characters or less.\n    const MAX_TOTAL_DESC_LEN = 300;\n\n    // In any case, we want to include the linkUrl at the end of the description\n    const LINK_STRING = `${SOURCE_REFERENCE_STRING}: ${linkUrl}`;\n    const TOTAL_LINK_LEN = 3 + LINK_STRING.length;\n    const MAX_RAW_DESC_LEN = MAX_TOTAL_DESC_LEN - TOTAL_LINK_LEN;\n\n    let description = ``;\n    if (MAX_TOTAL_DESC_LEN &gt; TOTAL_LINK_LEN) {\n        if (rawDescription.length &lt;= MAX_RAW_DESC_LEN) {\n            if (rawDescription.length === 0) {\n                description = LINK_STRING;\n            }\n            else {\n                description = `${rawDescription} - ${LINK_STRING}`;\n            }\n        }\n        else {\n            description = `${rawDescription.substring(0, MAX_RAW_DESC_LEN - 1)}... ${LINK_STRING}`;\n        }\n    }\n    else {\n        // Very unlikely to occur... incredibly long linkUrl / LINK_STRING\n        if (LINK_STRING.length &gt; MAX_TOTAL_DESC_LEN) {\n            description = shortenString(LINK_STRING, MAX_TOTAL_DESC_LEN);\n        }\n        else {\n            description = LINK_STRING;\n        }\n    }\n    return description;\n}\n\nmodule.exports = {\n    Runbook\n};\n</code></pre>",
            "number": 9,
            "type": "manual"
        },
        {
            "title": "File: utils.js",
            "description": "<pre><code class=\"language-plaintext\">/*\n * utils.js\n * Data conversion tool for runbooks (RBA).\n * This tool converts HTML sources (website or local files)\n * into runbooks in the RBA import format.\n * Requires: node (node.js runtime)\n * Version: 1\n * Date: 2022-02-04\n * Author: IBM\n * © Copyright IBM Corp. 2021, 2022  All Rights Reserved.\n * Use as is - no support\n */\n\n// Shorten the given string to a maximum of maxChars, including\n// the \"...\" shortening indicator. MaxChars must be greater than 3.\nfunction shortenString(string, maxChars = 60) {\n    let shortened = string || ``;\n    if (maxChars &gt; 3 &amp;&amp; shortened.length &gt; maxChars - 3) {\n        shortened = `${shortened.substring(0, maxChars - 3)}...`;\n    }\n    return shortened;\n}\n\n// Simplify and collapse whitespace from the given string:\n// - replace all whitespace (e.g., newlines, &amp;nbsp;) with blanks\n// - replace sequences of blanks with a single blank\n// Returns the converted string\nfunction sanitizeWhitespace(string) {\n    let sanitized = string || ``;\n    sanitized = sanitized.replace(/\\s/g, ` `);\n    sanitized = sanitized.replace(/  +/g, ` `);\n    return sanitized;\n}\n\n// Remove or convert extra whitespace that is located outside of pre-formatted blocks:\n// - Tokenize by &lt;pre&gt; and &lt;/pre&gt;\n// - Simplify and collapse whitespace from the parts that are outside outside of &lt;pre&gt;...&lt;/pre&gt; elements\n// - Supports nested &lt;pre&gt; elements, like \"&lt;pre&gt;abc&lt;pre&gt;def&lt;/pre&gt;ghi&lt;/pre&gt;\"\n//   as a single preformatted block\n// - If a starting &lt;pre&gt; is not matched by a closing &lt;/pre&gt;, then the complete text after\n//   the starting &lt;pre&gt; is treated as pre-formatted text\nfunction sanitizeStringOutsidePreformatted(string) {\n    const tokenArray = string.split(/(&lt;[/]?pre&gt;)/g);\n\n    let preformatLevel = 0;\n    const sanitizedArray = [];\n    for (let i = 0; i &lt; tokenArray.length; i++) {\n        const token = tokenArray[i];\n        if (token === `&lt;pre&gt;`) {\n            preformatLevel++;\n            sanitizedArray.push(token);\n        }\n        else if (token === `&lt;/pre&gt;`) {\n            preformatLevel--;\n            sanitizedArray.push(token);\n        }\n        else if (preformatLevel === 0) {\n            sanitizedArray.push(sanitizeWhitespace(token));\n        }\n        else {\n            sanitizedArray.push(token);\n        }\n    }\n    return sanitizedArray.join(``);\n}\n\n// Sanitize the string:\n//  - trim the string\n//  - reduce whitespace outside of preformatted (&lt;pre&gt;) blocks\n//  - finally, insert those newlines again that are actually required for preformatted blocks\n//    and have been replaced with &lt;CODE_BLOCK_NEWLINE&gt; substitutes before\nfunction sanitizeString(string) {\n    let sanitized = string || ``;\n    sanitized = sanitized.trim();\n    sanitized = sanitizeStringOutsidePreformatted(sanitized);\n    sanitized = sanitized.replace(/&lt;CODE_BLOCK_NEWLINE&gt;/g, `\\n`);\n    return sanitized;\n}\n\nmodule.exports = {\n    shortenString,\n    sanitizeString\n};\n</code></pre>",
            "number": 10,
            "type": "manual"
        },
        {
            "title": "Install the prerequisites",
            "description": "<p>Run the command</p><section class=\"rba-command\"><span class=\"rba-command-text\">npm install</span></section><p>&nbsp;to install the prerequisite packages that are listed in package.json.</p>",
            "number": 11,
            "type": "manual"
        },
        {
            "title": "Run the tool to convert some pages from IBM Documentation into runbooks",
            "description": "<p>The default configuration of the tool can be used without further modifications to convert some pages from IBM Documentation into runbooks:</p><section class=\"rba-command\"><span class=\"rba-command-text\">npm start</span></section><p>As the tool reads documents from IBM Documentation and attempts to convert them into runbooks, the tool writes detailed diagnostic information. You can modify the level of diagnostic output in config.js later on. Depending on the available network bandwidth, the tool may take some time to complete its task.</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p>",
            "number": 12,
            "type": "manual"
        },
        {
            "title": "Set the value of CURL_BASEURL to specify the deployment where you want to import the runbooks to",
            "number": 13,
            "type": "manual",
            "description": "<h3>Instructions for IBM Cloud Pak for Watson AIOps</h3><ul><li>Set the value of the CURL_BASEURL parameter to the IBM Cloud Pak for Watson AIOps user interface URL and replace the path with \"/aiops/api/story-manager/rba/v1\". For example, if the URL is \"https://cpd-cp4waiops.apps.mycluster.mycompany.com/zen/#/homepage\", then set the CURL_BASEURL to <i><strong>https://cpd-cp4waiops.apps.mycluster.mycompany.com/aiops/api/story-manager/rba/v1</strong></i></li><li>Once you have set the value click \"Update parameters\".</li></ul><p>&nbsp;</p><h3>Instructions for IBM Netcool Operations Insight running on Red Hat OpenShift</h3><ul><li>Set the value of the CURL_BASEURL parameter to the host name where the IBM Netcool Operations Insight service is running, prefix it with \"https://\" and append \"/api/v1/rba\", for example, <i><strong>https://netcool.n163.apps.mycluster.mycompany.com/api/v1/rba</strong></i></li><li>Once you have set the value click \"Update parameters\".</li></ul><p>&nbsp;</p><h3>Instructions for IBM Runbook Automation Private Deployment</h3><ul><li>Set the value of the CURL_BASEURL parameter to the host name and port where the runbook service is running (which may be different from the location where the Netcool OMNIbus/DASH UI server is running). The value has the format \"https://&lt;fullyQualifiedDomainName&gt;:&lt;rba-rbs-port&gt;/api/v1/rba\", for example, <i><strong>https://myhost.mycompany.com:3005/api/v1/rba</strong></i></li><li>Once you have set the value click \"Update parameters\".</li></ul>"
        },
        {
            "title": "Generate API key and set the value of CURL_AUTHENTICATION",
            "number": 14,
            "type": "manual",
            "description": "<p>The steps of this runbook require you to access the Runbook Automation API interface. To authenticate your requests, you need an API key. As the API key password will be visible in the execution record of this runbook you will be instructed to delete or recreate the API key in the last step of this runbook.</p><p>Open a command shell that supports the \"curl\" command. For the subsequent steps, you also need to have network connectivity to&nbsp;the host name part of&nbsp;<span class=\"rba-parameter\" data-id=\"CURL_BASEURL\"></span> from this command shell.</p><p>&nbsp;</p><h3>Instructions for IBM Cloud Pak for Watson AIOps</h3><ul><li>The command shell needs to support the \"base64\" encoding tool (in addition to the requirements listed above).</li><li>Generate a new API key. If you have performed this step before, you do not need to regenerate the key, you can use the existing API key value.<ul><li>In the IBM Cloud Pak for Watson AIOps user interface expand the user menu and open the menu item \"Profile and settings\" in a new browser tab.</li><li>On the \"Profile and settings\" details page click \"API key &gt; Generate new key\". Copy the API key value (&lt;api_key_value&gt;) and save it. If you lose the API key value, you need to regenerate it as it cannot be retrieved again. (But as indicated above, you should regenerate your API key once you are done with this runbook.)</li><li>You can close the browser tab with the \"Profile and settings\" details page.</li></ul></li><li>Use the command shell to encode the combined &lt;username&gt; and &lt;api_key_value&gt; (separated by a colon \":\" character) to generate a ZenApiKey token, where &lt;username&gt; is the user id that you used to login to the IBM Cloud Pak for Watson AIOps user interface:</li></ul><section class=\"rba-command\"><span class=\"rba-command-text\">echo -n \"&lt;username&gt;:&lt;api_key_value&gt;\" | base64 -w 0 | echo \"-H \\\"Authorization: ZenApiKey $(cat -)\\\"\"</span></section><ul><li>The result string should look like this: <i><strong>-H \"Authorization: ZenApiKey *******\"</strong></i></li><li>Edit the runbook parameter CURL_AUTHENTICATION. Copy the result string from the previous command and paste it as the parameter value of CURL_AUTHENTICATION.</li><li>Once you have set the value click \"Update parameters\".</li></ul><p>&nbsp;</p><h3>Instructions for deployments other than IBM Cloud Pak for Watson AIOps</h3><ol><li>Open a new browser tab.</li><li>Login to the product UI and navigate to the API key management page.</li><li>Create a new API key and note the API key name (&lt;api_key_name&gt;), description, and password (&lt;api_key_password&gt;). If you lose the password, you need to create another API key as it cannot be retrieved again.</li><li>Edit the runbook parameter value CURL_AUTHENTICATION and save the value [<i><strong>-u \"&lt;api_key_name&gt;:&lt;api_key_password&gt;\"</strong></i>] (without the brackets)</li><li>Once you have set the value click \"Update parameters\".</li><li>For more information, see the product documentation on API keys at <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://www.ibm.com/docs/en/runbook-automation?topic=api-keys\">IBM&nbsp;Documentation</a>.</li></ol><p>&nbsp;</p>"
        },
        {
            "title": "Test the connectivity to the target RBA API endpoint (optional)",
            "description": "<h3>Regular connectivity test</h3><p>To verify the correctness of the values of the CURL_AUTHENTICATION and CURL_BASEURL parameters, run the command</p><section class=\"rba-command\"><span class=\"rba-command-text\">curl -X GET -k&nbsp;<span class=\"rba-parameter\" data-id=\"CURL_AUTHENTICATION\"></span> \"<span class=\"rba-parameter\" data-id=\"CURL_BASEURL\"></span>/status\"</span></section><p>&nbsp;</p><p>&nbsp;This command is expected to print some informational data about the speed of the transfer along with some JSON result data similar to this:</p><pre><code class=\"language-plaintext\">{\"rbs\":0,\"as\":0,\"db\":0,\"connection\":{\"AWX\":0,\"BIGFIX\":2,\"IMPACT\":2,\"SCRIPT\":0},\"errors\":[]}</code></pre><p>Note that some of the connection items may have a different value than \"0\", and the \"errors\" array within the JSON result data might be nonempty (if the connection is in a failed state) - this is not a problem in the context of this runbook.</p><p>&nbsp;</p><h3>Connectivity test with more debug data (use only if needed)</h3><p>If no data or completely different data are printed by the previous command (e.g., some HTML content), then verify if the parameter values have been specified correctly. If the messages provided by the command are not sufficient, you can also add the \"-v\" option to debug the command:</p><section class=\"rba-command\"><span class=\"rba-command-text\">curl -X GET -v -k&nbsp;<span class=\"rba-parameter\" data-id=\"CURL_AUTHENTICATION\"></span> \"<span class=\"rba-parameter\" data-id=\"CURL_BASEURL\"></span>/status\"</span></section><p>Adjust the parameter values as needed, until the command works as expected.</p>",
            "number": 15,
            "type": "manual"
        },
        {
            "title": "Import the converted runbooks to your deployment",
            "description": "<p>Run the command</p><section class=\"rba-command\"><span class=\"rba-command-text\">curl -X POST -k -s -H \"Expect:\" -H \"Content-Type: application/json\"&nbsp;<span class=\"rba-parameter\" data-id=\"CURL_AUTHENTICATION\"></span> -d@./resultData/runbooks.ocp.docs.import.json &nbsp;\"<span class=\"rba-parameter\" data-id=\"CURL_BASEURL\"></span>/runbooks/import\"</span></section>",
            "number": 16,
            "type": "manual"
        },
        {
            "title": "Inspect the imported runbooks",
            "description": "<p>To inspect the imported runbooks:</p><ol><li>Copy the instructions from this step to some temporary file, or take a screen shot of this step (because the next instructions will close this page temporarily).</li><li>Navigate to the Library page.</li><li>Select the tag filter area and select \"converted-html-ibm-docs-rba\". This is the default tag for the converted runbooks from IBM Documentation, as configured within config.js.</li><li>Browse some of the runbooks that match the filter. In each of the runbooks, the first step contains a disclaimer that has been inserted by the conversion tool. You can suppress the generation of this disclaimer step within config.js.</li><li>Once you are done, you can delete these runbooks.</li><li>Navigate to the Execution page.</li><li>Select the execution of this runbook that is still in progress, and resume it.</li></ol><p>Congratulations - you have successfully installed and used the tool!</p>",
            "number": 17,
            "type": "manual"
        },
        {
            "title": "Adjust the tool to convert and import your own runbooks: Before you start",
            "description": "<p>The conversion tool accepts input documents in HTML format.</p><ul><li>If you are using some kind of web or intranet based documentation, then the conversion tool is able to \"crawl\" that web site and get the HTML documents directly from there (as you have seen above).</li><li>If you are using a different format (e.g., pdf, doc, odt) then you need to convert the source files to HTML format first. Many tools like Microsoft Word and LibreOffice support exporting documents in HTML format.</li><li>There are tools (e.g., provided by developer communities) that support batch conversion of various input formats to HTML format.</li><li>When you convert local source files from any type of format to HTML files as input for the conversion tool, ensure that the resulting HTML files do not contain unknown characters. For example, sometimes Umlaut characters are not properly exported to the HTML files.</li><li>You can ignore those cases when the replacement character (�) is used instead of a bullet at the beginning of a list item. In the context of a list item, this replacement character will be interpreted as an indicator that an unordered list should be used. You can customize the list of expected indicators for unordered lists in the configuration file of the conversion&nbsp;tool.</li></ul><p>The configuration file (config.js) includes two ready-to-use sample sections for converting runbooks from web pages (IBM Documentation and Wikipedia) and one sample section for converting&nbsp;runbooks from the local file system.</p><p>In many cases, adjusting this configuration file will be sufficient to generate runbooks that are of high quality and that contain a high percentage of the content of the original source documents.</p><p>If you find that some aspect of the conversion&nbsp;tool itself does not satisfy your particular needs, then feel free to adjust the tool accordingly. It is sample code that that is provided as-is and that you may tailor to your specific requirements.</p><p>As you advance to converting&nbsp;your own runbooks, you should plan to:</p><ul><li>Allow some time to figure out which patterns (see the next step for an explanation) are suited best to match the structure of your current operational procedures, and potentially to tune these patterns.</li><li>Allow some time to verify that the resulting runbooks are complete. In particular, images are not converted and need to be added manually.</li></ul><p>&nbsp;</p>",
            "number": 18,
            "type": "manual"
        },
        {
            "title": "Get familiar with the configuration options, and run the tool to convert your own runbooks",
            "description": "<p>Read the configuration file config.js, and adjust the configuration values to your preferences.</p><p>The configuration file provides a default set of patterns. Each pattern defines a combination of HTML elements that are candidates for the runbook title and for the runbook step titles, along with further definitions that control which parts of the document end up within the runbook steps themselves.</p><p>To proceed towards getting the best runbook results based on your input data, you will probably need to evaluate the structure of your input data: What are the candidates to become runbook titles (e.g., \"h1\" elements)? What are the candidates to become runbook step titles (e.g., \"h2\" elements)? The comments in config.js guide you through that process.</p><p>Start with a small set of source documents that are typical for your environment, and tune the configuration until the resulting runbooks meet your expectations. Ideally, not many changes are needed, and the existing patterns fit your source documents nicely.</p><p>Use the same commands that you used previously to convert and import the runbooks from IBM Documentation.</p>",
            "number": 19,
            "type": "manual"
        },
        {
            "title": "Only if needed: Split large result files and import them individually",
            "description": "<p>If the generated runbook file (e.g., \"runbooks.rba.docs.import.json\" or \"importRunbooks.json\") is larger than 1 MB, then it cannot be imported in a single operation. Instead, it has to be split into multiple JSON files, and each of them has to be imported separately.</p><p>If you have the \"jq\" tool installed, you can use the command</p><section class=\"rba-command\"><span class=\"rba-command-text\">cat importRunbooks.json | jq .[] -c | split -l 100 --filter='jq . -cs &gt; $FILE' - importRunbooks.json.</span></section><p>to split the file into chunks of 100 runbooks each, named importRunbooks.json.aa, importRunbooks.json.ab, etc. If the chunk files are still too large, then use a value that is lower than 100, and iterate this process until each chunk file has a size of less than 1 MB.</p><p>Then import each of the chunks to your runbook deployment.</p>",
            "number": 20,
            "type": "manual"
        },
        {
            "title": "Delete API key",
            "number": 21,
            "type": "manual",
            "description": "<h3>Instructions for IBM Cloud Pak for Watson AIOps</h3><ul><li>In the IBM Cloud Pak for Watson AIOps user interface expand the user menu and open the menu item \"Profile and settings\" in a new browser tab.</li><li>On the \"Profile and settings\" details page click \"API key &gt; Revoke current key\".<ul><li>Alternatively, if you need a new API key anyway, you can also click \"API key &gt; Regenerate key\". Copy the API key value and save it for the next time when you want to use the API.</li></ul></li><li>You can close the browser tab with the \"Profile and settings\" details page.</li></ul><p>&nbsp;</p><h3>Instructions for deployments other than IBM Cloud Pak for Watson AIOps</h3><ul><li>Navigate to the API key management page.</li><li>Identify the API key that you created in step 14, and delete it.</li></ul>"
        }
    ],
    "parameters": [
        {
            "name": "CURL_BASEURL",
            "description": "See step 13 for instructions how to create the value for this parameter. You can start with an empty value but you have to supply a value before proceeding to step 14.",
            "type": "string",
            "minLength": 0
        },
        {
            "name": "CURL_AUTHENTICATION",
            "description": "See step 14 for instructions how to create the value for this parameter. You can start with an empty value but you have to supply a value before proceeding to step 15.",
            "type": "string",
            "minLength": 0,
            "format": "password"
        }
    ],
    "tags": [
        "rbaimport",
        "sample"
    ]
}
